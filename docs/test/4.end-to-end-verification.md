# End-to-End Verification Runbook (M0.2 → M0.4)

This document contains **all manual testing commands and steps** to validate the FinPass PoC through:

- **M0.2** Issuer (DB + migrations + `/issue`)
- **M0.3** Wallet ↔ Issuer integration (`/issue-with-proof`, wallet proof signature, VC storage + UI)
- **M0.4** Verifier scaffold (`/verify/challenge`, `/verify`, signed decision token)

> Assumptions
> - Postgres via Docker Compose in repo root
> - Issuer runs on `http://localhost:8080`
> - Wallet runs on `http://localhost:3000`
> - Verifier runs on `http://localhost:8090`

---

## Quick map: which service owns which endpoint

Issuer (`localhost:8080`):

- `GET /.well-known/openid-credential-issuer`
- `GET /jwks.json`
- `POST /issue`
- `POST /issue-with-proof`
- `GET /status/{credId}`

Verifier (`localhost:8090`):

- `GET /.well-known/openid-provider`
- `GET /jwks.json`
- `GET /verify/challenge`
- `POST /verify`

---

## Happy path checklist (copy/paste friendly)

Run these in separate terminals.

### Terminal A — Postgres

From repo root (`finpass/`):

```bash
docker compose up -d
docker ps --format "table {{.Names}}\t{{.Ports}}"
```

Expected:
- `finpass-postgres` shows `0.0.0.0:15432->5432/tcp`

### Terminal B — Issuer

From `finpass/issuer`:

```bash
./mvnw -DskipTests spring-boot:run
```

Expected:
- You see Spring Boot startup logs ending with something like `Started ...`.

Sanity check (new terminal):

```bash
curl -s http://localhost:8080/.well-known/openid-credential-issuer
curl -s http://localhost:8080/jwks.json
```

Expected:
- `/.well-known/openid-credential-issuer` JSON includes `credential_endpoint`, `credential_endpoint_with_proof`, and `jwks_uri`
- `/jwks.json` JSON includes a top-level `keys` array with one Ed25519 JWK

### Terminal C — Verifier

1) Start verifier from repo root (`finpass/`).

Recommended (avoids manual copy/paste of JWKS):

Using system Maven:

```bash
TRUSTED_ISSUER_PUBLIC_JWK="$(curl -s http://localhost:8080/jwks.json)" \
mvn -f verifier/pom.xml -DskipTests spring-boot:run
```

Using the Maven wrapper that exists under `issuer/`:

```bash
TRUSTED_ISSUER_PUBLIC_JWK="$(curl -s http://localhost:8080/jwks.json)" \
./issuer/mvnw -f ./verifier/pom.xml -DskipTests spring-boot:run
```

Expected:
- Verifier starts and binds to port `8090` (Spring Boot logs show `Tomcat started on port 8090`).

Sanity check (new terminal):

```bash
curl -s http://localhost:8090/.well-known/openid-provider
curl -s http://localhost:8090/jwks.json
curl -s http://localhost:8090/verify/challenge
```

Expected:
- `/.well-known/openid-provider` returns JSON (not 404)
- `/jwks.json` returns verifier public JWKS
- `/verify/challenge` returns JSON like `{ "challenge": "<uuid>", "expiresIn": 300 }`

### Terminal D — Issue a credential (Issuer)

```bash
curl -s -X POST http://localhost:8080/issue \
  -H 'Content-Type: application/json' \
  -d '{
    "holderDid": "did:key:EXAMPLE",
    "passportData": {"name":"Alice","dob":"1990-01-01","country":"US"}
  }'
```

Expected:
- JSON includes `credId`, `commitmentJwt`
- Inside `commitmentJwt` payload:
  - `iss` is `did:example:issuer`
  - `sub` is `did:key:EXAMPLE`

Tip:
- `commitmentJwt` is the token you must send to verifier. If you accidentally paste `credentialJwt` or a truncated token, verifier will return `Invalid commitmentJwt`.

### Terminal E — Verify (Verifier)

1) Get a one-time challenge:

```bash
curl -s http://localhost:8090/verify/challenge
```

Expected:
- JSON includes `challenge` and `expiresIn`

2) Call `/verify` with the `challenge` and the `commitmentJwt` from the issuer response.

Recommended (avoids copy/paste mistakes and broken shell quotes):

```bash
ISSUE_JSON="$(curl -s -X POST http://localhost:8080/issue \
  -H 'Content-Type: application/json' \
  -d '{"holderDid":"did:key:EXAMPLE","passportData":{"name":"Alice","dob":"1990-01-01","country":"US"}}')"

COMMITMENT_JWT="$(python - <<'PY'
import json, os
print(json.loads(os.environ['ISSUE_JSON'])['commitmentJwt'])
PY)"

CHALLENGE="$(curl -s http://localhost:8090/verify/challenge | python -c 'import sys,json; print(json.load(sys.stdin)["challenge"])')"

VERIFY_PAYLOAD="$(python - <<'PY'
import json, os
print(json.dumps({
  "holderDid": "did:key:EXAMPLE",
  "challenge": os.environ["CHALLENGE"],
  "commitmentJwt": os.environ["COMMITMENT_JWT"],
  "proof": "poc-proof-placeholder",
  "publicSignals": {"predicate":"over_18","result": True,"challenge": os.environ["CHALLENGE"]},
  "requestedClaims": ["over_18"],
}))
PY)"

curl -i -s -X POST http://localhost:8090/verify \
  -H 'Content-Type: application/json' \
  -d "$VERIFY_PAYLOAD"
```

Alternative (manual):

```bash
curl -i -s -X POST http://localhost:8090/verify \
  -H 'Content-Type: application/json' \
  -d '{
    "holderDid": "did:key:EXAMPLE",
    "challenge": "<CHALLENGE_FROM_STEP_1>",
    "commitmentJwt": "<COMMITMENT_JWT_FROM_ISSUER_RESPONSE>",
    "proof": "poc-proof-placeholder",
    "publicSignals": {
      "predicate": "over_18",
      "result": true,
      "challenge": "<CHALLENGE_FROM_STEP_1>"
    },
    "requestedClaims": ["over_18"]
  }'
```

Expected:
- `HTTP/1.1 200`
- Response JSON includes:
  - `decisionToken` (JWT)
  - `assuranceLevel` == `LOW`
  - `verifiedClaims` contains `over_18`
  - `expiresIn` == `300`

If you see a `zsh` continuation prompt like `>` while pasting the command, your quotes are likely unbalanced. Use the recommended snippet above.

---

## Optional: Wallet UI flow (M0.3)

If you want to validate the Wallet UI path (instead of using `curl` to issue), do this after Issuer is up.

From `finpass/wallet`:

```bash
npm install
npm start
```

Open `http://localhost:3000` and:

1) Create or import wallet.
2) In **Get Passport Credential**, enter:
   - Name: `Alice`
   - DOB: `1990-01-01`
   - Country: `US`
3) Click **Get Credential**.

Expected:
- A credential appears under **Your Credentials**.
- After refresh, the credential still appears.

## Verifier negative tests (M0.4)

These assume you already completed the happy path and have a valid `commitmentJwt`.

### A) Challenge replay

1) Get a challenge and successfully call `/verify`.
2) Re-send the same `/verify` request using the same `challenge` again.

Expected:
- `400` JSON error with message like `Challenge already used`.

### B) Wrong challenge binding

Send a request where `publicSignals.challenge` does not equal the top-level `challenge`.

Expected:
- `400` JSON error with message like `Proof must bind to challenge`.

### C) Invalid predicate result

Send `publicSignals.result: false`.

Expected:
- `400` JSON error with message like `Proof result must be true`.

---

## 6) Decode decision token

The decision token is a JWT. You can decode locally (no verification) with:

```bash
python - << 'PY'
import base64, json, sys

def b64url(s):
    s += '=' * ((4 - len(s) % 4) % 4)
    return base64.urlsafe_b64decode(s.encode()).decode()

jwt = sys.argv[1]
header, payload, sig = jwt.split('.')
print('HEADER:', json.dumps(json.loads(b64url(header)), indent=2))
print('PAYLOAD:', json.dumps(json.loads(b64url(payload)), indent=2))
PY "<DECISION_TOKEN_JWT>"
```

Expected claims include:
- `iss` == verifier DID
- `sub` == holder DID
- `verified_at`
- `assurance_level: "LOW"`
- `verified_claims: ["over_18"]`
- `expires_in: 300`
- `exp` present

---

## Troubleshooting

### Issuer fails to start: port 8080 in use

```bash
lsof -nP -iTCP:8080 -sTCP:LISTEN
kill <PID>
```

### Verifier fails to start: missing trusted issuer JWK

You must set `TRUSTED_ISSUER_PUBLIC_JWK`.
Use:

```bash
curl -s http://localhost:8080/jwks.json
```

Then pass that value (or keys[0]) to the verifier.
